mod lexer;
mod parser;
mod runtime;

use std::{env, fs};
use std::path::Path;
use lexer::lexer_core::Lexer;
use parser::parser_core::Parser;
use runtime::environment::Environment;
use runtime::runtime_core::Evaluator;

fn main() {
    // Collect command-line arguments
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: {} <path to .pr file>", args[0]);
        std::process::exit(1);
    }

    let file_path = &args[1];
    let path = Path::new(file_path);

    // Check if the file exists and is a .pr file
    if !path.exists() || path.extension().unwrap_or_default() != "pr" {
        eprintln!("Invalid file path or file is not a .pr file!");
        std::process::exit(1);
    }

    // Read the file content
    let source = match fs::read_to_string(path) {
        Ok(content) => content,
        Err(e) => {
            eprintln!("Failed to read file: {:?}", e);
            std::process::exit(1);
        }
    };

    // Lexical analysis
    let mut lexer = Lexer::new(source);
    let tokens = lexer.scan_tokens();

    // Display tokens generated by the lexer
    println!("Tokens:");
    for token in &tokens {
        println!("{:?}", token);
    }

    // Parsing
    let mut parser = Parser::new(tokens);
    let ast = match parser.parse() {
        Ok(expr) => expr,
        Err(e) => {
            eprintln!("Failed to parse: {:?}", e);
            std::process::exit(1);
        }
    };

    // Display the Abstract Syntax Tree (AST)
    println!("\nAbstract Syntax Tree (AST):");
    println!("{:?}", ast);

    // Setup environment and evaluator
    let environment = Environment::new();
    let mut evaluator = Evaluator::new(environment);

    // Evaluation
    match evaluator.evaluate(&ast) {
        Ok(result) => println!("\nResult: {:?}", result),
        Err(e) => {
            eprintln!("Failed to evaluate: {:?}", e);
            std::process::exit(1);
        }
    }
}
